import { ConvInfo } from './conv_util';
import { MatrixOrientation, NDArrayMath } from './math';
import { Array1D, Array2D, Array3D, Array4D, NDArray, Scalar } from './ndarray';
export declare class NDArrayMathCPU extends NDArrayMath {
    constructor(safeMode?: boolean);
    protected cloneInternal<T extends NDArray>(ndarray: T): T;
    protected slice1DInternal(input: Array1D, begin: number, size: number): Array1D;
    protected slice2DInternal(input: Array2D, begin: [number, number], size: [number, number]): Array2D;
    protected slice3DInternal(input: Array3D, begin: [number, number, number], size: [number, number, number]): Array3D;
    protected slice4DInternal(input: Array4D, begin: [number, number, number, number], size: [number, number, number, number]): Array4D;
    protected copy2DInternal(source: Array2D, sourceBeginRowCol: [number, number], sourceSizeRowCol: [number, number], dest: Array2D, destBeginRowCol: [number, number], destSizeRowCol: [number, number]): void;
    protected concat1DInternal(a: Array1D, b: Array1D): Array1D;
    protected concat2DInternal(a: Array2D, b: Array2D, axis: number): Array2D;
    protected concat3DInternal(a: Array3D, b: Array3D, axis: number): Array3D;
    protected concat4DInternal(a: Array4D, b: Array4D, axis: number): Array4D;
    protected scaledArrayAddInternal<T extends NDArray>(c1: Scalar, a: T, c2: Scalar, b: T): T;
    protected negInternal<T extends NDArray>(a: T): T;
    protected addInternal<T extends NDArray>(a: T, b: T): T;
    protected subInternal<T extends NDArray>(a: T, b: T): T;
    protected matMulInternal(a: Array2D, b: Array2D, aOrientation?: MatrixOrientation, bOrientation?: MatrixOrientation): Array2D;
    protected multiplyInternal<T extends NDArray>(a: T, b: T): T;
    protected divideInternal<T extends NDArray>(a: T, b: T): T;
    protected sumInternal(ndarray: NDArray): Scalar;
    protected argMinInternal(ndarray: NDArray): Scalar;
    protected argMaxInternal(ndarray: NDArray): Scalar;
    protected argMaxEqualsInternal(x1: NDArray, x2: NDArray): Scalar;
    protected topKInternal(ndarray: NDArray, k: number): {
        values: Array1D;
        indices: Array1D;
    };
    protected minInternal(ndarray: NDArray): Scalar;
    protected maxInternal(ndarray: NDArray): Scalar;
    protected expInternal<T extends NDArray>(ndarray: T): T;
    protected logInternal<T extends NDArray>(ndarray: T): T;
    protected sqrtInternal<T extends NDArray>(ndarray: T): T;
    protected logSumExpInternal(ndarray: NDArray): Scalar;
    protected reluInternal<T extends NDArray>(ndarray: T): T;
    protected absInternal<T extends NDArray>(ndarray: T): T;
    protected sigmoidInternal<T extends NDArray>(ndarray: T): T;
    protected sinInternal<T extends NDArray>(ndarray: T): T;
    protected cosInternal<T extends NDArray>(ndarray: T): T;
    protected tanInternal<T extends NDArray>(ndarray: T): T;
    protected asinInternal<T extends NDArray>(ndarray: T): T;
    protected acosInternal<T extends NDArray>(ndarray: T): T;
    protected atanInternal<T extends NDArray>(ndarray: T): T;
    protected sinhInternal<T extends NDArray>(ndarray: T): T;
    protected coshInternal<T extends NDArray>(ndarray: T): T;
    protected tanhInternal<T extends NDArray>(ndarray: T): T;
    protected stepInternal<T extends NDArray>(ndarray: T): T;
    protected conv2dInternal(x: Array3D, filter: Array4D, bias: Array1D | null, convInfo: ConvInfo): Array3D;
    protected conv2dDerInputInternal(dy: Array3D, filter: Array4D, convInfo: ConvInfo): Array3D;
    protected conv2dDerFilterInternal(x: Array3D, dY: Array3D, convInfo: ConvInfo): Array4D;
    protected conv2dDerBiasInternal(dY: Array3D): Array1D;
    protected switchDimInternal<T extends NDArray>(t: T, newDim: number[]): T;
    private pool(x, convInfo, poolType);
    protected maxPoolInternal(x: Array3D, convInfo: ConvInfo): Array3D;
    maxPoolPositions(x: Array3D, convInfo: ConvInfo): Array3D;
    protected maxPoolBackpropInternal(dy: Array3D, x: Array3D, convInfo: ConvInfo): Array3D;
    protected minPoolInternal(x: Array3D, convInfo: ConvInfo): Array3D;
    protected avgPoolInternal(x: Array3D, convInfo: ConvInfo): Array3D;
    protected resizeBilinear3DInternal(x: Array3D, newShape2D: [number, number], alignCorners: boolean): Array3D;
    protected batchNormalization3DInternal(x: Array3D, mean: Array3D | Array1D, variance: Array3D | Array1D, varianceEpsilon?: number, scale?: Array3D | Array1D, offset?: Array3D | Array1D): Array3D;
}
